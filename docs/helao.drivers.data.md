# helao.drivers.data package

## Subpackages

* [helao.drivers.data.analyses package](helao.drivers.data.analyses.md)
  * [Submodules](helao.drivers.data.analyses.md#submodules)
  * [helao.drivers.data.analyses.base_analysis module](helao.drivers.data.analyses.md#module-helao.drivers.data.analyses.base_analysis)
    * [`BaseAnalysis`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis)
      * [`BaseAnalysis.analysis_codehash`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.analysis_codehash)
      * [`BaseAnalysis.analysis_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.analysis_name)
      * [`BaseAnalysis.analysis_params`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.analysis_params)
      * [`BaseAnalysis.analysis_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.analysis_timestamp)
      * [`BaseAnalysis.analysis_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.analysis_uuid)
      * [`BaseAnalysis.export_analysis()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.export_analysis)
      * [`BaseAnalysis.gen_uuid()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.gen_uuid)
      * [`BaseAnalysis.inputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.inputs)
      * [`BaseAnalysis.outputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.outputs)
      * [`BaseAnalysis.process_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.process_name)
      * [`BaseAnalysis.process_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.process_timestamp)
      * [`BaseAnalysis.process_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.process_uuid)
      * [`BaseAnalysis.run_type`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.run_type)
      * [`BaseAnalysis.technique_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.base_analysis.BaseAnalysis.technique_name)
  * [helao.drivers.data.analyses.echeuvis_stability module](helao.drivers.data.analyses.md#module-helao.drivers.data.analyses.echeuvis_stability)
    * [`EcheUvisAnalysis`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis)
      * [`EcheUvisAnalysis.__init__()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.__init__)
      * [`EcheUvisAnalysis.analysis_codehash`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.analysis_codehash)
      * [`EcheUvisAnalysis.analysis_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.analysis_name)
      * [`EcheUvisAnalysis.analysis_params`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.analysis_params)
      * [`EcheUvisAnalysis.analysis_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.analysis_timestamp)
      * [`EcheUvisAnalysis.analysis_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.analysis_uuid)
      * [`EcheUvisAnalysis.ca_potential_vrhe`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.ca_potential_vrhe)
      * [`EcheUvisAnalysis.calc_output()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.calc_output)
      * [`EcheUvisAnalysis.inputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.inputs)
      * [`EcheUvisAnalysis.outputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.outputs)
      * [`EcheUvisAnalysis.plate_id`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.plate_id)
      * [`EcheUvisAnalysis.process_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.process_name)
      * [`EcheUvisAnalysis.process_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.process_timestamp)
      * [`EcheUvisAnalysis.process_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.process_uuid)
      * [`EcheUvisAnalysis.run_type`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.run_type)
      * [`EcheUvisAnalysis.sample_no`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.sample_no)
      * [`EcheUvisAnalysis.technique_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisAnalysis.technique_name)
    * [`EcheUvisInputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs)
      * [`EcheUvisInputs.__init__()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.__init__)
      * [`EcheUvisInputs.baseline`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.baseline)
      * [`EcheUvisInputs.baseline_ocv`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.baseline_ocv)
      * [`EcheUvisInputs.baseline_ocv_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.baseline_ocv_act)
      * [`EcheUvisInputs.baseline_spec`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.baseline_spec)
      * [`EcheUvisInputs.baseline_spec_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.baseline_spec_act)
      * [`EcheUvisInputs.get_datamodels()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.get_datamodels)
      * [`EcheUvisInputs.insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.insitu)
      * [`EcheUvisInputs.insitu_ca`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.insitu_ca)
      * [`EcheUvisInputs.insitu_ca_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.insitu_ca_act)
      * [`EcheUvisInputs.insitu_spec`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.insitu_spec)
      * [`EcheUvisInputs.insitu_spec_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.insitu_spec_act)
      * [`EcheUvisInputs.presitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.presitu)
      * [`EcheUvisInputs.presitu_ocv`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.presitu_ocv)
      * [`EcheUvisInputs.presitu_ocv_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.presitu_ocv_act)
      * [`EcheUvisInputs.presitu_spec`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.presitu_spec)
      * [`EcheUvisInputs.presitu_spec_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.presitu_spec_act)
      * [`EcheUvisInputs.process_params`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisInputs.process_params)
    * [`EcheUvisOutputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs)
      * [`EcheUvisOutputs.agg_baseline`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.agg_baseline)
      * [`EcheUvisOutputs.agg_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.agg_insitu)
      * [`EcheUvisOutputs.agg_method`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.agg_method)
      * [`EcheUvisOutputs.agg_presitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.agg_presitu)
      * [`EcheUvisOutputs.baseline_max_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.baseline_max_rescaled)
      * [`EcheUvisOutputs.baseline_min_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.baseline_min_rescaled)
      * [`EcheUvisOutputs.bin_baseline`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.bin_baseline)
      * [`EcheUvisOutputs.bin_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.bin_insitu)
      * [`EcheUvisOutputs.bin_presitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.bin_presitu)
      * [`EcheUvisOutputs.bin_wavelength`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.bin_wavelength)
      * [`EcheUvisOutputs.insitu_max_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.insitu_max_rescaled)
      * [`EcheUvisOutputs.insitu_min_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.insitu_min_rescaled)
      * [`EcheUvisOutputs.lower_wl_idx`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.lower_wl_idx)
      * [`EcheUvisOutputs.mean_abs_omT_diff`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.mean_abs_omT_diff)
      * [`EcheUvisOutputs.mean_abs_omT_ratio`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.mean_abs_omT_ratio)
      * [`EcheUvisOutputs.mean_ref_dark`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.mean_ref_dark)
      * [`EcheUvisOutputs.mean_ref_light`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.mean_ref_light)
      * [`EcheUvisOutputs.model_computed_fields`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.model_computed_fields)
      * [`EcheUvisOutputs.model_config`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.model_config)
      * [`EcheUvisOutputs.model_fields`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.model_fields)
      * [`EcheUvisOutputs.noagg_epoch`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_epoch)
      * [`EcheUvisOutputs.noagg_omt_baseline`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_omt_baseline)
      * [`EcheUvisOutputs.noagg_omt_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_omt_insitu)
      * [`EcheUvisOutputs.noagg_omt_presitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_omt_presitu)
      * [`EcheUvisOutputs.noagg_omt_ratio`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_omt_ratio)
      * [`EcheUvisOutputs.noagg_presitu_epoch`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_presitu_epoch)
      * [`EcheUvisOutputs.noagg_presitu_wavelength`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_presitu_wavelength)
      * [`EcheUvisOutputs.noagg_wavelength`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.noagg_wavelength)
      * [`EcheUvisOutputs.presitu_max_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.presitu_max_rescaled)
      * [`EcheUvisOutputs.presitu_min_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.presitu_min_rescaled)
      * [`EcheUvisOutputs.rscl_baseline`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.rscl_baseline)
      * [`EcheUvisOutputs.rscl_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.rscl_insitu)
      * [`EcheUvisOutputs.rscl_presitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.rscl_presitu)
      * [`EcheUvisOutputs.smth_baseline`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.smth_baseline)
      * [`EcheUvisOutputs.smth_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.smth_insitu)
      * [`EcheUvisOutputs.smth_presitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.smth_presitu)
      * [`EcheUvisOutputs.upper_wl_idx`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.upper_wl_idx)
      * [`EcheUvisOutputs.wavelength`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.EcheUvisOutputs.wavelength)
    * [`parse_spechlo()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.parse_spechlo)
    * [`refadjust()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.echeuvis_stability.refadjust)
  * [helao.drivers.data.analyses.icpms_local module](helao.drivers.data.analyses.md#module-helao.drivers.data.analyses.icpms_local)
    * [`IcpmsAnalysis`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis)
      * [`IcpmsAnalysis.__init__()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.__init__)
      * [`IcpmsAnalysis.analysis_codehash`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.analysis_codehash)
      * [`IcpmsAnalysis.analysis_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.analysis_name)
      * [`IcpmsAnalysis.analysis_params`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.analysis_params)
      * [`IcpmsAnalysis.analysis_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.analysis_timestamp)
      * [`IcpmsAnalysis.analysis_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.analysis_uuid)
      * [`IcpmsAnalysis.calc_output()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.calc_output)
      * [`IcpmsAnalysis.global_sample_label`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.global_sample_label)
      * [`IcpmsAnalysis.inputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.inputs)
      * [`IcpmsAnalysis.outputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.outputs)
      * [`IcpmsAnalysis.process_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.process_name)
      * [`IcpmsAnalysis.process_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.process_timestamp)
      * [`IcpmsAnalysis.process_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.process_uuid)
      * [`IcpmsAnalysis.run_type`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.run_type)
      * [`IcpmsAnalysis.technique_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsAnalysis.technique_name)
    * [`IcpmsInputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs)
      * [`IcpmsInputs.__init__()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs.__init__)
      * [`IcpmsInputs.get_datamodels()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs.get_datamodels)
      * [`IcpmsInputs.global_sample_label`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs.global_sample_label)
      * [`IcpmsInputs.icpms`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs.icpms)
      * [`IcpmsInputs.icpms_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs.icpms_act)
      * [`IcpmsInputs.mass_spec`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs.mass_spec)
      * [`IcpmsInputs.process_params`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsInputs.process_params)
    * [`IcpmsOutputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs)
      * [`IcpmsOutputs.element`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.element)
      * [`IcpmsOutputs.fom_key`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.fom_key)
      * [`IcpmsOutputs.global_sample_label`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.global_sample_label)
      * [`IcpmsOutputs.isotope`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.isotope)
      * [`IcpmsOutputs.model_computed_fields`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.model_computed_fields)
      * [`IcpmsOutputs.model_config`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.model_config)
      * [`IcpmsOutputs.model_fields`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.model_fields)
      * [`IcpmsOutputs.value`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.icpms_local.IcpmsOutputs.value)
  * [helao.drivers.data.analyses.uvis_bkgsubnorm module](helao.drivers.data.analyses.md#module-helao.drivers.data.analyses.uvis_bkgsubnorm)
    * [`DryUvisAnalysis`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis)
      * [`DryUvisAnalysis.__init__()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.__init__)
      * [`DryUvisAnalysis.action_attr`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.action_attr)
      * [`DryUvisAnalysis.analysis_codehash`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.analysis_codehash)
      * [`DryUvisAnalysis.analysis_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.analysis_name)
      * [`DryUvisAnalysis.analysis_params`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.analysis_params)
      * [`DryUvisAnalysis.analysis_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.analysis_timestamp)
      * [`DryUvisAnalysis.analysis_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.analysis_uuid)
      * [`DryUvisAnalysis.calc_output()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.calc_output)
      * [`DryUvisAnalysis.inputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.inputs)
      * [`DryUvisAnalysis.outputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.outputs)
      * [`DryUvisAnalysis.plate_id`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.plate_id)
      * [`DryUvisAnalysis.process_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.process_name)
      * [`DryUvisAnalysis.process_timestamp`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.process_timestamp)
      * [`DryUvisAnalysis.process_uuid`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.process_uuid)
      * [`DryUvisAnalysis.run_type`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.run_type)
      * [`DryUvisAnalysis.sample_no`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.sample_no)
      * [`DryUvisAnalysis.technique_name`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisAnalysis.technique_name)
    * [`DryUvisInputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs)
      * [`DryUvisInputs.__init__()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.__init__)
      * [`DryUvisInputs.get_datamodels()`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.get_datamodels)
      * [`DryUvisInputs.insitu_spec`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.insitu_spec)
      * [`DryUvisInputs.insitu_spec_act`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.insitu_spec_act)
      * [`DryUvisInputs.process_params`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.process_params)
      * [`DryUvisInputs.ref_dark_spec`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.ref_dark_spec)
      * [`DryUvisInputs.ref_dark_spec_acts`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.ref_dark_spec_acts)
      * [`DryUvisInputs.ref_darks`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.ref_darks)
      * [`DryUvisInputs.ref_light_spec`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.ref_light_spec)
      * [`DryUvisInputs.ref_light_spec_acts`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.ref_light_spec_acts)
      * [`DryUvisInputs.ref_lights`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisInputs.ref_lights)
    * [`DryUvisOutputs`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs)
      * [`DryUvisOutputs.agg_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.agg_insitu)
      * [`DryUvisOutputs.agg_method`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.agg_method)
      * [`DryUvisOutputs.bin_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.bin_insitu)
      * [`DryUvisOutputs.bin_wavelength`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.bin_wavelength)
      * [`DryUvisOutputs.insitu_max_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.insitu_max_rescaled)
      * [`DryUvisOutputs.insitu_min_rescaled`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.insitu_min_rescaled)
      * [`DryUvisOutputs.lower_wl_idx`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.lower_wl_idx)
      * [`DryUvisOutputs.mean_ref_dark`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.mean_ref_dark)
      * [`DryUvisOutputs.mean_ref_light`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.mean_ref_light)
      * [`DryUvisOutputs.model_computed_fields`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.model_computed_fields)
      * [`DryUvisOutputs.model_config`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.model_config)
      * [`DryUvisOutputs.model_fields`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.model_fields)
      * [`DryUvisOutputs.rscl_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.rscl_insitu)
      * [`DryUvisOutputs.smth_insitu`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.smth_insitu)
      * [`DryUvisOutputs.upper_wl_idx`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.upper_wl_idx)
      * [`DryUvisOutputs.wavelength`](helao.drivers.data.analyses.md#helao.drivers.data.analyses.uvis_bkgsubnorm.DryUvisOutputs.wavelength)
  * [Module contents](helao.drivers.data.analyses.md#module-helao.drivers.data.analyses)
* [helao.drivers.data.loaders package](helao.drivers.data.loaders.md)
  * [Submodules](helao.drivers.data.loaders.md#submodules)
  * [helao.drivers.data.loaders.localfs module](helao.drivers.data.loaders.md#module-helao.drivers.data.loaders.localfs)
    * [`EcheUvisLoader`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.EcheUvisLoader)
      * [`EcheUvisLoader.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.EcheUvisLoader.__init__)
      * [`EcheUvisLoader.get_recent()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.EcheUvisLoader.get_recent)
    * [`HelaoAction`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction)
      * [`HelaoAction.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.__init__)
      * [`HelaoAction.action_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.action_name)
      * [`HelaoAction.action_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.action_params)
      * [`HelaoAction.action_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.action_timestamp)
      * [`HelaoAction.action_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.action_uuid)
      * [`HelaoAction.hlo`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.hlo)
      * [`HelaoAction.hlo_file`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.hlo_file)
      * [`HelaoAction.hlo_file_tup`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.hlo_file_tup)
      * [`HelaoAction.read_hlo_file()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoAction.read_hlo_file)
    * [`HelaoExperiment`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoExperiment)
      * [`HelaoExperiment.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoExperiment.__init__)
      * [`HelaoExperiment.experiment_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoExperiment.experiment_name)
      * [`HelaoExperiment.experiment_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoExperiment.experiment_params)
      * [`HelaoExperiment.experiment_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoExperiment.experiment_timestamp)
      * [`HelaoExperiment.experiment_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoExperiment.experiment_uuid)
    * [`HelaoModel`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel)
      * [`HelaoModel.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel.__init__)
      * [`HelaoModel.helao_type`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel.helao_type)
      * [`HelaoModel.json`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel.json)
      * [`HelaoModel.name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel.name)
      * [`HelaoModel.params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel.params)
      * [`HelaoModel.timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel.timestamp)
      * [`HelaoModel.uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoModel.uuid)
    * [`HelaoProcess`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoProcess)
      * [`HelaoProcess.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoProcess.__init__)
      * [`HelaoProcess.process_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoProcess.process_params)
      * [`HelaoProcess.process_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoProcess.process_timestamp)
      * [`HelaoProcess.process_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoProcess.process_uuid)
      * [`HelaoProcess.technique_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoProcess.technique_name)
    * [`HelaoSequence`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoSequence)
      * [`HelaoSequence.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoSequence.__init__)
      * [`HelaoSequence.sequence_label`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoSequence.sequence_label)
      * [`HelaoSequence.sequence_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoSequence.sequence_name)
      * [`HelaoSequence.sequence_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoSequence.sequence_params)
      * [`HelaoSequence.sequence_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoSequence.sequence_timestamp)
      * [`HelaoSequence.sequence_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.HelaoSequence.sequence_uuid)
    * [`LocalLoader`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader)
      * [`LocalLoader.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.__init__)
      * [`LocalLoader.clear_cache()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.clear_cache)
      * [`LocalLoader.get_act()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.get_act)
      * [`LocalLoader.get_exp()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.get_exp)
      * [`LocalLoader.get_hlo()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.get_hlo)
      * [`LocalLoader.get_prc()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.get_prc)
      * [`LocalLoader.get_seq()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.get_seq)
      * [`LocalLoader.get_yml()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.localfs.LocalLoader.get_yml)
  * [helao.drivers.data.loaders.pgs3 module](helao.drivers.data.loaders.md#module-helao.drivers.data.loaders.pgs3)
    * [`EcheUvisLoader`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.EcheUvisLoader)
      * [`EcheUvisLoader.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.EcheUvisLoader.__init__)
      * [`EcheUvisLoader.get_recent()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.EcheUvisLoader.get_recent)
      * [`EcheUvisLoader.get_sequence()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.EcheUvisLoader.get_sequence)
    * [`HelaoAction`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction)
      * [`HelaoAction.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.__init__)
      * [`HelaoAction.action_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.action_name)
      * [`HelaoAction.action_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.action_params)
      * [`HelaoAction.action_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.action_timestamp)
      * [`HelaoAction.action_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.action_uuid)
      * [`HelaoAction.hlo`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.hlo)
      * [`HelaoAction.hlo_file`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.hlo_file)
      * [`HelaoAction.hlo_file_tup`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoAction.hlo_file_tup)
    * [`HelaoExperiment`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoExperiment)
      * [`HelaoExperiment.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoExperiment.__init__)
      * [`HelaoExperiment.experiment_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoExperiment.experiment_name)
      * [`HelaoExperiment.experiment_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoExperiment.experiment_params)
      * [`HelaoExperiment.experiment_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoExperiment.experiment_timestamp)
      * [`HelaoExperiment.experiment_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoExperiment.experiment_uuid)
    * [`HelaoLoader`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader)
      * [`HelaoLoader.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.__init__)
      * [`HelaoLoader.clear_cache()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.clear_cache)
      * [`HelaoLoader.connect()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.connect)
      * [`HelaoLoader.get_act()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.get_act)
      * [`HelaoLoader.get_exp()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.get_exp)
      * [`HelaoLoader.get_hlo()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.get_hlo)
      * [`HelaoLoader.get_json()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.get_json)
      * [`HelaoLoader.get_prc()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.get_prc)
      * [`HelaoLoader.get_seq()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.get_seq)
      * [`HelaoLoader.get_sql()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.get_sql)
      * [`HelaoLoader.reconnect()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.reconnect)
      * [`HelaoLoader.run_raw_query()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoLoader.run_raw_query)
    * [`HelaoModel`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel)
      * [`HelaoModel.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel.__init__)
      * [`HelaoModel.helao_type`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel.helao_type)
      * [`HelaoModel.json`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel.json)
      * [`HelaoModel.name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel.name)
      * [`HelaoModel.params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel.params)
      * [`HelaoModel.timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel.timestamp)
      * [`HelaoModel.uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoModel.uuid)
    * [`HelaoProcess`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoProcess)
      * [`HelaoProcess.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoProcess.__init__)
      * [`HelaoProcess.process_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoProcess.process_name)
      * [`HelaoProcess.process_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoProcess.process_params)
      * [`HelaoProcess.process_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoProcess.process_timestamp)
      * [`HelaoProcess.process_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoProcess.process_uuid)
    * [`HelaoSequence`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSequence)
      * [`HelaoSequence.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSequence.__init__)
      * [`HelaoSequence.sequence_name`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSequence.sequence_name)
      * [`HelaoSequence.sequence_params`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSequence.sequence_params)
      * [`HelaoSequence.sequence_timestamp`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSequence.sequence_timestamp)
      * [`HelaoSequence.sequence_uuid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSequence.sequence_uuid)
    * [`HelaoSolid`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSolid)
      * [`HelaoSolid.__init__()`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSolid.__init__)
      * [`HelaoSolid.sample_label`](helao.drivers.data.loaders.md#helao.drivers.data.loaders.pgs3.HelaoSolid.sample_label)
  * [Module contents](helao.drivers.data.loaders.md#module-helao.drivers.data.loaders)

## Submodules

## helao.drivers.data.HTEdata_legacy module

## helao.drivers.data.analysis_driver module

Data analysis driver

Handles Helao analyses uploads to S3.

### *class* helao.drivers.data.analysis_driver.HelaoAnalysisSyncer(action_serv)

Bases: [`HelaoSyncer`](#helao.drivers.data.sync_driver.HelaoSyncer)

HelaoAnalysisSyncer is a class that handles the synchronization of analysis tasks to S3 and API. It inherits from HelaoSyncer and manages a queue of analysis tasks, ensuring they are processed and uploaded to the appropriate storage and API endpoints.

Attributes:
: base (Base): The base server instance.
  running_tasks (dict): A dictionary to keep track of running tasks.
  config_dict (dict): Configuration dictionary from the server configuration.
  world_config (dict): World configuration dictionary.
  local_ana_root (str): Local directory path for storing analysis results.
  max_tasks (int): Maximum number of concurrent tasks.
  task_queue (asyncio.PriorityQueue): Priority queue for managing tasks.
  task_set (set): Set of task identifiers.
  syncer_loop (asyncio.Task): The main loop task for processing the queue.
  s3 (pgs3.Client): S3 client for uploading data.
  s3r (pgs3.Resource): S3 resource for managing data.
  bucket (str): S3 bucket name.
  region (str): S3 region name.

Methods:
: \_\_init_\_(self, action_serv: Base):
  : Initializes the HelaoAnalysisSyncer instance with the given action server.
  <br/>
  get_loader(self):
  : Initializes the loader for analysis models used by the driver.batch_\* methods.
  <br/>
  sync_exit_callback(self, task: asyncio.Task):
  : Callback function to handle task completion and cleanup.
  <br/>
  async enqueue_calc(self, calc_tup: Tuple[UUID, pd.DataFrame, dict, str], rank: int = 5):
  : Adds a calculation tuple to the task queue with the specified priority rank.
  <br/>
  async syncer(self):
  : Main loop coroutine that processes the task queue and manages task execution.
  <br/>
  async sync_ana(self, calc_tup: Tuple[UUID, pd.DataFrame, dict, str], retries: int = 3, rank: int = 5):
  : Performs the analysis and handles the synchronization of results to S3 and API.
  <br/>
  async to_api(self, req_model: dict, retries: int = 3):
  : Sends the analysis model to the API via POST or PATCH requests.
  <br/>
  async batch_calc_echeuvis(self, plate_id: Optional[int] = None, sequence_uuid: Optional[UUID] = None, params: dict = {}, recent: bool = True):
  : Generates a list of EcheUvisAnalysis tasks from a sequence or plate_id.
  <br/>
  async batch_calc_dryuvis(self, plate_id: Optional[int] = None, sequence_uuid: Optional[UUID] = None, params: dict = {}, recent: bool = True):
  : Generates a list of DryUvisAnalysis tasks from a sequence or plate_id.
  <br/>
  async batch_calc_icpms_local(self, sequence_zip_path: str = “”, params: dict = {}):
  : Generates a list of IcpmsAnalysis tasks from a local sequence zip file.
  <br/>
  shutdown(self):
  : Placeholder method for handling shutdown procedures.

#### \_\_init_\_(action_serv)

Initializes the AnalysisDriver instance.

Args:
: action_serv (Base): The base action server instance.

Attributes:
: base (Base): The base action server instance.
  config_dict (dict): Configuration parameters from the server configuration.
  world_config (dict): World configuration from the action server.
  local_ana_root (str): Path to the local analysis root directory.
  max_tasks (int): Maximum number of tasks allowed.
  task_queue (asyncio.PriorityQueue): Priority queue for managing tasks.
  task_set (set): Set of tasks.
  running_tasks (dict): Dictionary of currently running tasks.
  syncer_loop (asyncio.Task): Asynchronous task for the syncer loop.

#### base *: [`Base`](helao.servers.md#helao.servers.base.Base)*

#### *async* batch_calc_dryuvis(plate_id=None, sequence_uuid=None, params={}, recent=True)

Asynchronously calculates dry UV-Vis analysis for a batch of data.

Args:
: plate_id (Optional[int]): The ID of the plate to filter the data. Defaults to None.
  sequence_uuid (Optional[UUID]): The UUID of the sequence to filter the data. Defaults to None.
  params (dict): Additional parameters for the analysis. Defaults to an empty dictionary.
  recent (bool): If True, only recent data is considered. Defaults to True.

Returns:
: None

Raises:
: None

Notes:
: - The function retrieves recent data based on the provided parameters and filters it.
  - It retries the data retrieval up to 3 times if no data is returned initially.
  - The filtered data is then processed and enqueued for dry UV-Vis analysis.

#### *async* batch_calc_echeuvis(plate_id=None, sequence_uuid=None, params={}, recent=True)

Asynchronously calculates ECHEUVIS analysis for a batch of processes.

Args:
: plate_id (Optional[int]): The ID of the plate to filter the sequences. Defaults to None.
  sequence_uuid (Optional[UUID]): The UUID of the sequence to filter. Defaults to None.
  params (dict): Additional parameters for the analysis. Defaults to an empty dictionary.
  recent (bool): If True, filters sequences based on the most recent date. Defaults to True.

Returns:
: None

#### *async* batch_calc_icpms_local(sequence_zip_path='', params={})

Asynchronously calculates ICP-MS (Inductively Coupled Plasma Mass Spectrometry) analysis for a batch of processes 
from a local sequence zip file.

Args:
: sequence_zip_path (str): The path to the sequence zip file containing the processes.
  params (dict): A dictionary of parameters to be used in the ICP-MS analysis.

Returns:
: None

#### *async* enqueue_calc(calc_tup, rank=5)

Adds a calculation task to the queue with a specified priority.

Args:
: calc_tup (Tuple[UUID, pd.DataFrame, dict, str]): A tuple containing:
  : - process_uuid (UUID): Unique identifier for the process.
    - query_df (pd.DataFrame): DataFrame containing the query data.
    - ana_params (dict): Dictionary of analysis parameters.
    - str: Additional string parameter.
  <br/>
  rank (int, optional): Priority rank for the task in the queue. Defaults to 5.

Returns:
: None

#### get_loader()

Initializes the loader for the EcheUvis data and sets up the S3 client and resources.

This method sets up the pgs3.LOADER with the EcheUvisLoader using the provided
configuration dictionary. It initializes the S3 client and resources, and sets the
S3 bucket and region.

Attributes:
: pgs3.LOADER (EcheUvisLoader): The loader instance for EcheUvis data.
  self.s3 (S3Client): The S3 client instance.
  self.s3r (S3Resource): The S3 resource instance.
  self.bucket (str): The S3 bucket name.
  self.region (str): The S3 region name.

#### running_tasks *: `dict`*

#### shutdown()

#### *async* sync_ana(calc_tup, retries=3, rank=5)

Asynchronously performs analysis synchronization.

This method takes a tuple containing a UUID, a pandas DataFrame, a dictionary of analysis parameters,
and a function name. It performs the analysis using the provided function and parameters, exports the
analysis results, and uploads them to an S3 bucket if configured to do so.

Args:
: calc_tup (Tuple[UUID, pd.DataFrame, dict, str]): A tuple containing the process UUID, the DataFrame
  : to be analyzed, the analysis parameters, and the analysis function name.
  <br/>
  retries (int, optional): The number of retries for the synchronization. Defaults to 3.
  rank (int, optional): The rank of the analysis. Defaults to 5.

Returns:
: bool: True if the synchronization was successful, False otherwise.

#### sync_exit_callback(task)

Callback function to handle the completion of an asynchronous task.

This function is intended to be used as a callback for when an asyncio.Task
completes. It removes the task from the running_tasks dictionary and the 
task_set set if they exist.

Args:
: task (asyncio.Task): The completed asyncio task.

#### *async* syncer()

Asynchronous method to process tasks from the syncer queue.

This method continuously checks the task queue and processes tasks as long as the number of running tasks is less than the maximum allowed tasks. For each task, it creates an asynchronous analysis task and adds a callback for when the task is done.

The method performs the following steps:
1. Prints a message indicating the start of the syncer queue processor task.
2. Enters an infinite loop to continuously check the task queue.
3. If the number of running tasks is less than the maximum allowed tasks:

> 1. Retrieves a task from the task queue.
> 2. Prints a message indicating the creation of an analysis task.
> 3. Creates an asynchronous analysis task and adds it to the running tasks.
> 4. Adds a callback to the task for when it is done.
> 5. Marks the task as done in the task queue.
1. Sleeps for a short duration before checking the task queue again.

Note:
: This method is designed to run indefinitely and should be managed appropriately to ensure it does not block other operations.

#### *async* to_api(req_model, retries=3)

Asynchronously sends a request to the API to push analysis data. If the initial request fails,
it retries up to a specified number of times. If all retries fail, it sends a failure report 
to a debug endpoint.

Args:
: req_model (dict): The request model containing analysis data to be sent to the API.
  retries (int, optional): The number of times to retry the request in case of failure. Defaults to 3.

Returns:
: bool: True if the API push was successful, False otherwise.

## helao.drivers.data.archive_driver module

Archive class handles local sample DB and legacy DB lookup

TODO:
1. consolidate tray_export_json, tray_export_csv, tray_export_icpms, and make 
tray_unloadall call the export function
2. write tray_import function to consume exported json or csv and ingest into local
sqlite database, import needs to check for existing global_sample_labels

### *class* helao.drivers.data.archive_driver.Archive(action_serv)

Bases: `object`

#### \_\_init_\_(action_serv)

#### action_startup_config()

#### append_sample_status(samples, newstatus)

* **Return type:**
  `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### assign_new_sample_status(samples, newstatus)

#### *async* create_samples(reference_samples_in, action=None)

creates new samples in the db from provided refernces samples

* **Return type:**
  `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### *async* custom_add_gas(custom=None, source_gas_in=None, volume_ml=0.0, action=None)

adds new gas from a ‘reservoir’ to a custom position

* **Return type:**
  `Tuple`[`bool`, `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]]

#### *async* custom_add_liquid(custom=None, source_liquid_in=None, volume_ml=0.0, combine_liquids=False, dilute_liquids=True, action=None)

adds new liquid from a ‘reservoir’ to a custom position

* **Return type:**
  `Tuple`[`bool`, `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]]

#### custom_assembly_allowed(custom=None)

#### custom_dest_allowed(custom=None)

#### custom_dilution_allowed(custom=None)

#### custom_is_destroyed(custom=None)

checks if the custom position is a waste, injector
and similar position which fully comsumes and destroyes a
sample if selected as a destination

* **Return type:**
  `bool`

#### *async* custom_load(custom=None, load_sample_in=None, \*args, \*\*kwargs)

#### *async* custom_query_sample(custom=None, \*args, \*\*kwargs)

* **Return type:**
  `Tuple`[`ErrorCodes`, `Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### *async* custom_replace_sample(custom=None, sample=None)

* **Return type:**
  `Tuple`[`bool`, `Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### *async* custom_unload(custom=None, destroy_liquid=False, destroy_gas=False, destroy_solid=False, keep_liquid=False, keep_solid=False, keep_gas=False, action=None, \*args, \*\*kwargs)

* **Return type:**
  `Tuple`[`bool`, `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `dict`]

#### *async* custom_unloadall(destroy_liquid=False, destroy_gas=False, destroy_solid=False, keep_liquid=False, keep_solid=False, keep_gas=False, action=None, \*args, \*\*kwargs)

* **Return type:**
  `Tuple`[`bool`, `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `dict`]

#### *async* custom_update_position(custom=None, sample=None, dilute=False, \*args, \*\*kwargs)

* **Return type:**
  `Tuple`[`bool`, `Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### *async* destroy_sample(sample=None)

will mark a sample as destroyed in the sample db
and update its parameters accordingly

* **Return type:**
  `bool`

#### *async* generate_plate_sample_no_list(active=None, plate_id=None, sample_code=None, skip_n_samples=None, direction=None, sample_nos=[], sample_nos_operator=None, platemap_xys=[], platemap_xys_operator=None)

generate the sample list based on filters:
- which direction to move
(raster rows, raster columns, left-to-right, top-to-bottom)
- platemap composition (A>0 and/or B=0)
- platemap sample codes (code=0, code!=1)
- skip every N samples
- sample number equals, gt, gte, lt, lte, not
- platemap x,y equals, gt, gte, lt, lte, not

#### load_config()

#### *async* new_ref_samples(samples_in, sample_out_type='', sample_position='', action=None, combine_liquids=False)

volume_ml and sample_position need to be updated after the
function call by the function calling this.

* **Return type:**
  `Tuple`[`bool`, `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]]

#### *async* selective_destroy_samples(samples, destroy_liquid=False, destroy_gas=False, destroy_solid=False)

* **Return type:**
  `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### *async* tray_export_csv(tray=None, slot=None, myactive=None)

#### *async* tray_export_icpms(tray=None, slot=None, myactive=None, survey_runs=None, main_runs=None, rack=None, dilution_factor=None)

#### *async* tray_export_json(tray=None, slot=None, \*args, \*\*kwargs)

#### *async* tray_get_next_full(after_tray=None, after_slot=None, after_vial=None)

Finds the next full vial after the current vial position
defined in micropal.

#### *async* tray_load(tray=None, slot=None, vial=None, load_sample_in=None, \*args, \*\*kwargs)

* **Return type:**
  `Tuple`[`ErrorCodes`, `Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### *async* tray_new_position(req_vol=2.0, \*args, \*\*kwargs)

Returns an empty vial position for given max volume.
For mixed vial sizes the req_vol helps to choose the proper vial for sample volume.
It will select the first empty vial which has the smallest volume that still can hold req_vol

#### *async* tray_query_sample(tray=None, slot=None, vial=None)

* **Return type:**
  `Tuple`[`ErrorCodes`, `Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]]

#### *async* tray_unload(tray=None, slot=None, \*args, \*\*kwargs)

* **Return type:**
  `Tuple`[`bool`, `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `dict`]

#### *async* tray_unloadall(\*args, \*\*kwargs)

* **Return type:**
  `Tuple`[`bool`, `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `List`[`Union`[`AssemblySample`, `LiquidSample`, `GasSample`, `SolidSample`, `NoneSample`]], `dict`]

#### *async* tray_update_position(tray=None, slot=None, vial=None, sample=None, dilute=False, \*args, \*\*kwargs)

#### *async* update_samples_from_db()

#### *async* update_samples_from_db_helper(sample)

pulls the newest sample data from the db,
only of global_label is not none, else sample is a ref sample

#### write_config()

## helao.drivers.data.calc_driver module

Local data calculation server

This server performs calculations on locally saved data for in-situ amendment of running
sequences, i.e. repeated experiment looping, thresholding, etc.

TODO:
Calc.fill_syringe_volume_check() and Calc.check_co2_purge_level() need to be updated to
handle orchestrator requests originating outside of the config launch group.

### *class* helao.drivers.data.calc_driver.Calc(action_serv)

Bases: `object`

In-sequence FOM calculation driver.

#### \_\_init_\_(action_serv)

#### calc_uvis_abs(activeobj)

Figure of merit calculator for UVIS TR, DR, and T techniques.

#### *async* check_co2_purge_level(activeobj)

#### *async* fill_syringe_volume_check(activeobj)

#### gather_seq_data(seq_reldir, action_name)

Get all files using FileMapper to traverse ACTIVE/FINISHED/SYNCED.

#### gather_seq_exps(seq_reldir, exp_name)

Get all exp dicts using FileMapper to traverse ACTIVE/FINISHED/SYNCED.

#### get_seq_dict(seq_reldir)

Get sequence dict.

#### shutdown()

### helao.drivers.data.calc_driver.handlenan_savgol_filter(d_arr, window_length, polyorder, delta=1.0, deriv=0, replacenan_value=0.1)

Custom savgol_filter from JCAPDataProcess uvis_basics.py, updated for array ops.

### helao.drivers.data.calc_driver.refadjust(v, min_mthd_allowed, max_mthd_allowed, min_limit, max_limit)

Normalization func from JCAPDataProcess uvis_basics.py, updated for array ops.

### helao.drivers.data.calc_driver.squeeze_foms(d)

## helao.drivers.data.dbpack_driver module

### *class* helao.drivers.data.dbpack_driver.ActYml(path, \*\*kwargs)

Bases: `HelaoYml`

#### \_\_init_\_(path, \*\*kwargs)

### *class* helao.drivers.data.dbpack_driver.DBPack(action_serv)

Bases: `object`

Driver class for API push and S3 upload operations.

config_dict = {
: “aws_config_path”: “path_to_AWS_CONFIG_FILE”,
  “aws_bucket”: “helao.data.testing”

}

#### \_\_init_\_(action_serv)

#### *async* add_yml_task(yml_path, timeout=300)

#### cleanup_root()

#### *async* finish_acts(exp_yml)

#### *async* finish_exps(seq_yml)

#### *async* finish_pending()

#### *async* finish_yml(yml_path)

Primary function for processing ymls.

Args
yml_path[str]: local path to yml file

#### list_pending()

#### read_log()

#### rm(yml_path)

#### shutdown()

#### update_log(yml_path, flag_dict)

#### write_log()

#### *async* yml_task()

### *class* helao.drivers.data.dbpack_driver.ExpYml(path, \*\*kwargs)

Bases: `HelaoYml`

#### \_\_init_\_(path, \*\*kwargs)

#### create_process(group_idx)

Create process group from finished actions in progress[‘meta’].

#### get_actions()

Return a list of ActYml objects belonging to this experiment.

#### parse_yml(path)

### *class* helao.drivers.data.dbpack_driver.HelaoPath(\*args, \*\*kwargs)

Bases: `PosixPath`

Helao data path helper attributes.

#### *property* active

#### cleanup()

Remove empty directories in RUNS_ACTIVE or RUNS_FINISHED.

#### *property* finished

#### *property* relative

#### rename(status)

Rename this path to the target path.

The target path may be absolute or relative. Relative paths are
interpreted relative to the current working directory, *not* the
directory of the Path object.

Returns the new Path instance pointing to the target path.

#### *property* status_idx

#### *property* synced

### *class* helao.drivers.data.dbpack_driver.SeqYml(path, \*\*kwargs)

Bases: `HelaoYml`

#### \_\_init_\_(path, \*\*kwargs)

#### get_experiments()

Return a list of ExpYml objects belonging to this experiment.

#### parse_yml(path)

### *class* helao.drivers.data.dbpack_driver.YmlOps(dbp, yml)

Bases: `object`

#### \_\_init_\_(dbp, yml)

#### *async* to_api(progress_key, retry_num=2)

Submit to modelyst DB

#### to_finished()

Moves yml and data folder from ACTIVE to FINISHED path.

#### *async* to_s3(progress_key, retry_num=2)

Upload data_files and yml/json to S3

#### to_synced()

Moves yml and data folder from FINISHED to SYNCED path. Final state.

## helao.drivers.data.enum module

### *class* helao.drivers.data.enum.YmlType(value, names=None, \*, module=None, qualname=None, type=None, start=1, boundary=None)

Bases: `str`, `Enum`

#### action *= 'action'*

#### experiment *= 'experiment'*

#### sequence *= 'sequence'*

## helao.drivers.data.gpsim_driver module

## helao.drivers.data.sync_driver module

sync_driver.py

This module provides classes and functions for synchronizing Helao YAML files with S3 and an API. 
It includes functionality for converting dictionaries to JSON, moving files between directories, 
and handling synchronization progress.

Classes:
: HelaoYml: Represents a Helao YAML file and provides methods for managing its state and metadata.
  Progress: Manages the synchronization progress of a Helao YAML file.
  HelaoSyncer: Handles the synchronization of Helao YAML files with S3 and an API.

Functions:
: dict2json(input_dict: dict): Converts a dictionary to a file-like object containing JSON.
  move_to_synced(file_path: Path): Moves a file from the RUNS_FINISHED directory to the RUNS_SYNCED directory.
  revert_to_finished(file_path: Path): Moves a file from the RUNS_SYNCED directory to the RUNS_FINISHED directory.

### *class* helao.drivers.data.sync_driver.HelaoSyncer(action_serv, db_server_name='DB')

Bases: `object`

HelaoSyncer is a class responsible for synchronizing YAML files to S3 and an API. 
It manages tasks, handles file uploads, and ensures data consistency across different storage systems.

Attributes:
: progress (Dict[str, Progress]): A dictionary to track the progress of tasks.
  base (Base): The base server instance.
  running_tasks (dict): A dictionary to keep track of currently running tasks.
  config_dict (dict): Configuration parameters for the syncer.
  world_config (dict): World configuration parameters.
  max_tasks (int): Maximum number of concurrent tasks.
  aws_session (boto3.Session): AWS session for S3 operations.
  s3 (boto3.client): S3 client for file uploads.
  s3r (boto3.resource): S3 resource for file operations.
  bucket (str): S3 bucket name.
  api_host (str): API host URL.
  sequence_objs (dict): Dictionary to store sequence objects.
  task_queue (asyncio.PriorityQueue): Priority queue for managing tasks.
  aiolock (asyncio.Lock): Asyncio lock for synchronization.
  syncer_loop (asyncio.Task): Asyncio task for the syncer loop.

Methods:
: \_\_init_\_(self, action_serv: Base, db_server_name: str = “DB”):
  : Initializes the HelaoSyncer instance with the given action server and database server name.
  <br/>
  try_remove_empty(self, remove_target):
  : Attempts to remove an empty directory and returns success status.
  <br/>
  cleanup_root(self):
  : Removes leftover empty directories from the root.
  <br/>
  sync_exit_callback(self, task: asyncio.Task):
  : Callback function to handle the completion of a sync task.
  <br/>
  syncer(self):
  : Coroutine that runs the syncer loop, consuming tasks from the task queue.
  <br/>
  get_progress(self, yml_path: Path):
  : Returns progress from the global dictionary and updates the YAML path if not found.
  <br/>
  enqueue_yml(self, upath: Union[Path, str], rank: int = 5, rank_limit: int = -5):
  : Adds a YAML file to the sync queue with the specified priority.
  <br/>
  sync_yml(self, yml_path: Path, retries: int = 3, rank: int = 5, force_s3: bool = False, force_api: bool = False, compress: bool = False):
  : Coroutine for syncing a single YAML file.
  <br/>
  update_process(self, act_yml: HelaoYml, act_meta: Dict):
  : Updates processes in the experiment parent based on the action YAML and metadata.
  <br/>
  sync_process(self, exp_prog: Progress, force: bool = False):
  : Pushes unfinished processes to S3 and API from experiment progress.
  <br/>
  to_s3(self, msg: Union[dict, Path], target: str, retries: int = 5, compress: bool = False):
  : Uploads data to S3, either as a JSON object or a file.
  <br/>
  to_api(self, req_model: dict, meta_type: str, retries: int = 5):
  : Sends a POST or PATCH request to the Modelyst API.
  <br/>
  list_pending(self, omit_manual_exps: bool = True):
  : Finds and queues YAML files from the RUNS_FINISHED directory.
  <br/>
  finish_pending(self, omit_manual_exps: bool = True):
  : Finds and queues sequence YAML files from the RUNS_FINISHED directory.
  <br/>
  reset_sync(self, sync_path: str):
  : Resets a synced sequence zip or partially-synced sequence folder.
  <br/>
  shutdown(self):
  : Placeholder method for shutting down the syncer.
  <br/>
  unsync_dir(self, sync_dir: str):
  : Reverts a synced directory back to the RUNS_FINISHED state.

#### \_\_init_\_(action_serv, db_server_name='DB')

Initializes the SyncDriver instance.

Args:
: action_serv (Base): The action server instance.
  db_server_name (str, optional): The name of the database server. Defaults to “DB”.

Attributes:
: base (Base): The action server instance.
  config_dict (dict): Configuration parameters for the driver.
  world_config (dict): World configuration from the action server.
  max_tasks (int): Maximum number of tasks allowed.
  aws_session (boto3.Session or None): AWS session if AWS configuration is provided.
  s3 (boto3.client or None): S3 client if AWS configuration is provided.
  s3r (boto3.resource or None): S3 resource if AWS configuration is provided.
  bucket (str): AWS S3 bucket name.
  api_host (str): API host address.
  sequence_objs (dict): Dictionary to store sequence objects.
  task_queue (asyncio.PriorityQueue): Priority queue for tasks.
  running_tasks (dict): Dictionary to store running tasks.
  aiolock (asyncio.Lock): Asynchronous lock.
  syncer_loop (asyncio.Task): Asynchronous task for the syncer loop.

#### base *: [`Base`](helao.servers.md#helao.servers.base.Base)*

#### cleanup_root()

#### *async* enqueue_yml(upath, rank=5, rank_limit=-5)

Enqueue a YAML file to the task queue with a specified rank.

Args:
: upath (Union[Path, str]): The path to the YAML file to be enqueued.
  rank (int, optional): The priority rank for the task. Defaults to 5.
  rank_limit (int, optional): The minimum rank allowed for enqueuing. Defaults to -5.

Returns:
: None

Notes:
: - If the rank is below the rank_limit, the task will not be enqueued.
  - If the task is already running, it will not be enqueued.
  - The task is added to the queue with the specified rank if it passes the checks.

#### *async* finish_pending(omit_manual_exps=True)

Processes and enqueues pending sequences from the RUNS_FINISHED directory.

This method identifies pending sequences, logs the number of sequences to be enqueued,
and processes each sequence. If a corresponding .progress file exists in the RUNS_SYNCED
directory, it resets the sync state. Finally, it enqueues each sequence for further processing.

Args:
: omit_manual_exps (bool): If True, manual experiments are omitted from the pending list.
  : Defaults to True.

Returns:
: list: A list of pending sequences that were processed and enqueued.

#### get_progress(yml_path)

Retrieves or initializes the progress of a given YAML file.

This method checks if the specified YAML file exists. If it does not exist,
it initializes a new HelaoYml object, checks its paths, creates a Progress
object, and writes the progress dictionary. If the YAML file exists, it simply
initializes a Progress object with the given path.

Args:
: yml_path (Path): The path to the YAML file.

Returns:
: Progress: An instance of the Progress class representing the progress
  of the specified YAML file.

#### list_pending(omit_manual_exps=True)

Lists pending sequences in the RUNS_FINISHED directory.

This method searches for sequence files in the RUNS_FINISHED directory
and returns a list of pending sequences. By default, it omits sequences
that are manually orchestrated.

Args:
: omit_manual_exps (bool): If True, sequences containing ‘manual_orch_seq’
  : in their filename will be omitted from the list.
    Defaults to True.

Returns:
: list: A list of file paths to the pending sequence files.

#### progress *: `Dict`[`str`, [`Progress`](#helao.drivers.data.sync_driver.Progress)]*

#### reset_sync(sync_path)

Resets the synchronization state of a given path.

This method handles both zip files and directories. For zip files, it extracts
the contents (excluding .prg and .lock files) to a corresponding directory in
the RUNS_FINISHED path. For directories, it removes all .prg, .progress, and .lock
files and moves the directory back to the RUNS_FINISHED path.

Args:
: sync_path (str): The path to reset. This can be either a zip file or a directory.

Returns:
: bool: True if the reset was successful, False otherwise.

Raises:
: FileNotFoundError: If the provided path does not exist.
  ValueError: If the provided path is not in the RUNS_SYNCED directory.

#### running_tasks *: `dict`*

#### shutdown()

#### sync_exit_callback(task)

Callback function to handle the completion of an asyncio task.

This function is called when an asyncio task completes. It removes the task
from the running_tasks dictionary if it exists.

Args:
: task (asyncio.Task): The asyncio task that has completed.

#### *async* sync_process(exp_prog, force=False)

Synchronizes the progress of processes by checking unfinished processes and 
pushing their metadata to S3 or an API if certain conditions are met.

Args:
: exp_prog (Progress): The progress object containing the state of the experiment.
  force (bool, optional): If True, forces the synchronization regardless of other conditions. Defaults to False.

Returns:
: Progress: The updated progress object after synchronization.

The method performs the following steps:
1. Checks for unfinished processes in S3 and API.
2. For each unfinished process in S3:

> - Determines if the process should be pushed based on the force flag or other conditions.
> - If conditions are met, writes the process metadata to a local YAML file and syncs it to S3.
> - Updates the progress object to reflect the synchronization.
1. For each unfinished process in the API:
   : - Determines if the process should be pushed based on the completion of process actions.
     - If conditions are met, syncs the process metadata to the API.
     - Updates the progress object to reflect the synchronization.

#### *async* sync_yml(yml_path, retries=3, rank=5, force_s3=False, force_api=False, compress=False)

Synchronize a YAML file with S3 and API.

This function handles the synchronization of a YAML file by performing the following steps:
1. Check if the YAML file exists and if it is already synced.
2. Check the status of the YAML file and its children.
3. Push files to S3 if the YAML file is of type ‘action’.
4. Finish processes for ‘experiment’ type YAML files.
5. Patch the model and push the YAML file to S3 and API.
6. Move files to a synced directory and clean up.

Args:
: yml_path (Path): The path to the YAML file.
  retries (int, optional): Number of retries for syncing processes. Defaults to 3.
  rank (int, optional): Priority rank for the sync queue. Defaults to 5.
  force_s3 (bool, optional): Force push to S3 even if already done. Defaults to False.
  force_api (bool, optional): Force push to API even if already done. Defaults to False.
  compress (bool, optional): Compress files before pushing to S3. Defaults to False.

Returns:
: dict: A dictionary containing the progress information, excluding ‘process_metas’.

#### *async* syncer()

Asynchronous method to continuously process tasks from a queue and manage their execution.

This method runs an infinite loop that checks if the number of currently running tasks
is less than the maximum allowed tasks. If so, it retrieves the next task from the queue
and starts its execution if it is not already running.

The method performs the following steps:
1. Checks if the number of running tasks is less than the maximum allowed tasks.
2. Retrieves the next task from the task queue.
3. If the task is not already running, creates and starts an asynchronous task for it.
4. Adds a callback to handle the task’s completion.
5. Waits for a short period before repeating the process.

The tasks are expected to be YAML files, and the method ensures that each task is only
processed once at a time.

Attributes:
: running_tasks (dict): A dictionary to keep track of currently running tasks.
  max_tasks (int): The maximum number of tasks that can run concurrently.
  task_queue (asyncio.Queue): A queue from which tasks are retrieved.

Returns:
: None

#### *async* to_api(req_model, meta_type, retries=5)

Pushes a request model to an API endpoint asynchronously with retry logic.

Args:
: req_model (dict): The request model to be sent to the API.
  meta_type (str): The type of metadata being sent.
  retries (int, optional): The number of retry attempts in case of failure. Defaults to 5.

Returns:
: bool: True if the API push was successful, False otherwise.

Raises:
: Exception: If an exception occurs during the API request.

Notes:
: - If the API host is not configured, the function will skip the API push and return True.
  - The function will attempt to create a new resource with a POST request. If a 400 status code is received, it will switch to a PATCH request to update the resource.
  - If all retry attempts fail, the function will attempt to log the failure to a separate endpoint.

#### *async* to_s3(msg, target, retries=5, compress=False)

Uploads a message or file to an S3 bucket with optional retries and compression.

Args:
: msg (Union[dict, Path]): The message to upload, either as a dictionary or a file path.
  target (str): The target path in the S3 bucket.
  retries (int, optional): The number of retry attempts in case of failure. Defaults to 5.
  compress (bool, optional): Whether to compress the message before uploading. Defaults to False.

Returns:
: bool: True if the upload was successful, False otherwise.

Raises:
: Exception: If an unexpected error occurs during the upload process.

#### try_remove_empty(remove_target)

Attempts to remove a directory if it is empty. If the directory contains subdirectories,
it will recursively attempt to remove them if they are empty as well.

Args:
: remove_target (str): The path of the directory to be removed.

Returns:
: bool: True if the directory (and any subdirectories) were successfully removed, 
  : False otherwise.

Raises:
: Exception: If an error occurs while attempting to remove the directory, 
  : an error message will be logged.

#### unsync_dir(sync_dir)

Reverts the synchronization of a directory by performing the following actions:

1. Removes files with extensions .lock, .progress, or .prg.
2. Moves all other files to a corresponding directory in “RUNS_FINISHED”.

Args:
: sync_dir (str): The path to the directory to be unsynchronized.

Logs:
: A warning message indicating the successful reversion of the directory.

#### update_process(act_yml, act_meta)

Updates the process metadata and progress for a given action.

Args:
: act_yml (HelaoYml): The YAML configuration object for the action.
  act_meta (Dict): Metadata dictionary for the action.

Returns:
: The updated experiment progress object.

The function performs the following steps:
1. Retrieves the experiment progress from the given path.
2. Handles legacy experiments that do not have a process list.
3. Updates the process metadata and progress for the current action.
4. Deduplicates sample lists if necessary.
5. Registers the finished action in the process actions done list.
6. Writes the updated progress dictionary to the file.

### *class* helao.drivers.data.sync_driver.HelaoYml(target)

Bases: `object`

HelaoYml is a class that handles YAML file operations for Helao directories.

Attributes:
: target (Path): The target YAML file path.
  targetdir (Path): The directory containing the target YAML file.

Methods:
: \_\_init_\_(self, target: Union[Path, str]):
  : Initializes the HelaoYml object with the given target path.
  <br/>
  parts(self):
  : Returns the parts of the target path as a list.
  <br/>
  check_paths(self):
  : Checks if the target path exists and updates the target path if necessary.
  <br/>
  exists(self):
  : Checks if the target path exists.
  <br/>
  \_\_repr_\_(self):
  : Returns a string representation of the HelaoYml object.
  <br/>
  type(self):
  : Returns the type of the YAML file based on its stem.
  <br/>
  timestamp(self):
  : Returns the timestamp of the YAML file based on its stem.
  <br/>
  status(self):
  : Returns the status of the YAML file based on its directory.
  <br/>
  rename(self, status: str) -> str:
  : Renames the target path with the given status.
  <br/>
  status_idx(self):
  : Returns the index of the status in the parts of the target path.
  <br/>
  relative_path(self):
  : Returns the relative path of the target path.
  <br/>
  active_path(self):
  : Returns the active path of the target path.
  <br/>
  finished_path(self):
  : Returns the finished path of the target path.
  <br/>
  synced_path(self):
  : Returns the synced path of the target path.
  <br/>
  cleanup(self):
  : Removes empty directories in RUNS_ACTIVE or RUNS_FINISHED.
  <br/>
  list_children(self, yml_path: Path):
  : Lists the children YAML files in the given path.
  <br/>
  active_children(self) -> list:
  : Returns the active children YAML files.
  <br/>
  finished_children(self) -> list:
  : Returns the finished children YAML files.
  <br/>
  synced_children(self) -> list:
  : Returns the synced children YAML files.
  <br/>
  children(self) -> list:
  : Returns all children YAML files sorted by timestamp.
  <br/>
  misc_files(self) -> List[Path]:
  : Returns a list of miscellaneous files in the target directory.
  <br/>
  lock_files(self) -> List[Path]:
  : Returns a list of lock files in the target directory.
  <br/>
  hlo_files(self) -> List[Path]:
  : Returns a list of HLO files in the target directory.
  <br/>
  parent_path(self) -> Path:
  : Returns the parent path of the target YAML file.
  <br/>
  write_meta(self, meta_dict: dict):
  : Writes the given metadata dictionary to the target YAML file.

#### \_\_init_\_(target)

Initialize the SyncDriver with a target path.

Args:
: target (Union[Path, str]): The target path for the SyncDriver. It can be either a Path object or a string.

Raises:
: TypeError: If the target is neither a Path object nor a string.

#### *property* active_children *: list*

Retrieve a list of active children from the active path.

Returns:
: list: A list of active children.

#### *property* active_path

Returns the active path for the current run.

This method constructs and returns a Path object representing the
directory for active runs. It uses the rename method to generate
the directory name “RUNS_ACTIVE”.

Returns:
: Path: A Path object pointing to the “RUNS_ACTIVE” directory.

#### check_paths()

Checks and validates the paths for the Helao directory structure.

This method performs the following checks:
1. If the self.exists attribute is False, it iterates through the paths

> (self.active_path, self.finished_path, self.synced_path) to find
> an existing path and sets self.target to the first existing path found.
> If no existing path is found, it prints an error message.
1. If self.target is a directory, it sets self.targetdir to self.target
   and searches for .yml files with specific suffixes (-seq, -exp, -act).
   If multiple or no such .yml files are found, it raises a ValueError.
   Otherwise, it sets self.target to the found .yml file.
2. If self.target is not a directory, it sets self.targetdir to the parent
   directory of self.target.
3. It checks if any part of self.targetdir starts with “

   ```
   RUNS_
   ```

   ”. If not, it
   raises a ValueError.

Raises:
: ValueError: If multiple or no valid .yml files are found in the target
  : directory, or if the target is not located within a Helao
    RUNS_\* directory.

#### *property* children *: list*

Retrieve a sorted list of all child objects.

This method combines active, finished, and synced children into a single list
and sorts them based on their timestamp attribute.

Returns:
: list: A sorted list of all child objects.

#### cleanup()

Cleans up the target directory by removing empty directories.

This method checks if the target directory exists and is not the same as the
synced path. If the target directory does not exist or is the same as the
synced path, it returns “success”. Otherwise, it iterates through the parts
of the directory path and attempts to remove empty directories.

Returns:
: str: “success” if cleanup is successful or if the target directory does
  : not exist or is the same as the synced path. “failed” if a directory
    is not empty. A string representation of the error if a PermissionError
    occurs during directory removal.

#### *property* exists

Check if the target exists.

Returns:
: bool: True if the target exists, False otherwise.

#### *property* finished_children *: list*

Retrieve a list of finished child processes.

Returns:
: list: A list of finished child processes.

#### *property* finished_path

Generates a finished path by renaming the current path to “RUNS_FINISHED”.

Returns:
: Path: The new path with the name “RUNS_FINISHED”.

#### *property* hlo_files *: List[Path]*

Retrieve a list of .hlo files from the target directory.

Returns:
: List[Path]: A list of Path objects representing .hlo files in the target directory.

#### list_children(yml_path)

List and sort child YAML files by timestamp.

Args:
: yml_path (Path): The path to the parent directory containing YAML files.

Returns:
: List[HelaoYml]: A sorted list of HelaoYml objects based on their timestamp.

#### *property* lock_files *: List[Path]*

Retrieve a list of lock files in the target directory.

This method searches the target directory for files with the “.lock” suffix
and returns a list of their paths.

Returns:
: List[Path]: A list of paths to the lock files in the target directory.

#### *property* misc_files *: List[Path]*

Retrieve a list of miscellaneous files from the target directory.

This method scans the target directory and returns a list of files that do not have
the extensions ‘.yml’, ‘.hlo’, or ‘.lock’.

Returns:
: List[Path]: A list of Path objects representing the miscellaneous files.

#### *property* parent_path *: Path*

Determines the parent path based on the type of the current instance.

If the type is “sequence”, it returns the target path.
Otherwise, it searches for YAML files in the parent directories of 
active_path, finished_path, and synced_path, and returns the first match.

Returns:
: Path: The parent path based on the type or the first matching YAML file.

#### *property* parts

Returns a list of parts from the target.

Returns:
: list: A list containing the parts of the target.

#### *property* relative_path

Generate a relative path by joining parts of the path starting from the status index + 1.

Returns:
: str: The relative path as a string.

#### rename(status)

Renames a part of the file path with the given status.

* **Return type:**
  `str`

Args:
: status (str): The new status to replace in the file path.

Returns:
: str: The new file path with the updated status.

#### *property* status

Determine the status of the target directory.

This method extracts the status from the target directory path. It looks for
a directory part that starts with “

```
RUNS_
```

” and then splits this part to get
the status, which is converted to lowercase.

Returns:
: str: The status extracted from the target directory path.

#### *property* status_idx

Determine the index of the first element in self.parts that matches any of the valid statuses.

The method checks each element in self.parts to see if it matches any of the statuses in 
valid_statuses (“RUNS_ACTIVE”, “RUNS_FINISHED”, “RUNS_SYNCED”). It returns the index of the 
first matching element.

Returns:
: int: The index of the first element in self.parts that matches any of the valid statuses.

Raises:
: ValueError: If no element in self.parts matches any of the valid statuses.

#### *property* synced_children *: list*

Retrieve a list of children from the synced path.

Returns:
: list: A list of children from the synced path.

#### *property* synced_path

Generates a synchronized path by renaming the current path to “RUNS_SYNCED”.

Returns:
: Path: A Path object representing the synchronized path.

#### target *: `Path`*

#### targetdir *: `Path`*

#### *property* timestamp

Extracts and returns a timestamp from the filename of the target file.

The filename is expected to have a format where the timestamp is the first part,
separated by a hyphen, and follows the format “%Y%m%d.%H%M%S%f”.

Returns:
: datetime: A datetime object representing the extracted timestamp.

#### *property* type

Determines the type of the target based on its stem.

The method extracts the last part of the target’s stem (separated by a dash)
and uses it to look up the corresponding type in the ABR_MAP dictionary.

Returns:
: The type of the target as defined in the ABR_MAP dictionary.

#### write_meta(meta_dict)

Writes metadata to the target file in YAML format.

Args:
: meta_dict (dict): A dictionary containing metadata to be written.

Raises:
: Exception: If there is an issue writing to the target file.

### *class* helao.drivers.data.sync_driver.Progress(path)

Bases: `object`

Progress class to manage synchronization of Helao .yml and .prg files.

Attributes:
: ymlpath (HelaoYml): Path to the Helao YAML file.
  prg (Path): Path to the progress file.
  dict (Dict): Dictionary to store progress data.

Methods:
: \_\_init_\_(path: Union[Path, str]):
  : Initializes the Progress object with the given path.
  <br/>
  yml:
  : Property to get the HelaoYml object from the ymlpath.
  <br/>
  list_unfinished_procs():
  : Returns a pair of lists with non-synced s3 and api processes.
  <br/>
  read_dict():
  : Reads the progress dictionary from the .prg file.
  <br/>
  write_dict(new_dict: Optional[Dict] = None):
  : Writes the progress dictionary to the .prg file.
  <br/>
  s3_done:
  : Property to check if s3 synchronization is done.
  <br/>
  api_done:
  : Property to check if api synchronization is done.
  <br/>
  remove_prg():
  : Removes the .prg file.

#### \_\_init_\_(path)

Initialize the Progress with the given path.

Args:
: path (Union[Path, str]): The path to the .yml or .prg file.

Raises:
: ValueError: If the provided path is not a valid .yml or .prg file.

Notes:
: - If the path is a .yml file, it sets the ymlpath attribute.
  - If the path is a .prg file, it sets the prg attribute.
  - If the path is a string, it converts it to a Path object and performs the same checks.
  - If the prg attribute is not set, it derives it from the yml attribute.
  - If the .prg file does not exist, it initializes a dictionary with default values and writes it to the .prg file.
  - If the .prg file exists, it reads the dictionary from the file.

#### *property* api_done

Retrieves the value associated with the key “api” from the dictionary.

Returns:
: The value associated with the key “api” in the dictionary.

#### dict *: `Dict`*

#### list_unfinished_procs()

Returns a pair of lists with non-synced S3 and API processes.

This method checks the type of the YAML configuration. If the type is 
“experiment”, it identifies processes that are present in the 
“process_groups” but not in “process_s3” and “process_api”. These 
processes are considered unfinished and are returned as two separate 
lists: one for S3 and one for API. If the type is not “experiment”, 
it returns two empty lists.

Returns:
: tuple: A tuple containing two lists:
  : - s3_unf (list): List of process groups not synced with S3.
    - api_unf (list): List of process groups not synced with API.

#### prg *: `Path`*

#### read_dict()

Reads a YAML file specified by self.prg and loads its contents into self.dict.

This method uses the yml_load function to parse the YAML file and store the resulting dictionary in the self.dict attribute.

#### remove_prg()

Removes the program file associated with the driver.

This method unlinks (deletes) the program file (self.prg) from the filesystem.

#### *property* s3_done

Checks if the ‘s3’ key in the dictionary is marked as done.

Returns:
: bool: The value associated with the ‘s3’ key in the dictionary.

#### write_dict(new_dict=None)

Writes a dictionary to a file in YAML format.

Args:
: new_dict (Optional[Dict], optional): The dictionary to write. If None, 
  : the instance’s dictionary (self.dict) 
    will be written. Defaults to None.

Returns:
: None

#### *property* yml

Parses the YAML file located at the specified path and returns a HelaoYml object.

Returns:
: HelaoYml: An object representing the parsed YAML file.

#### ymlpath *: [`HelaoYml`](#helao.drivers.data.sync_driver.HelaoYml)*

## Module contents
