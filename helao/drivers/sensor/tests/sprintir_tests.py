
# Generated by CodiumAI
from helao-async.helao.drivers.sensor.sprintir_driver import SprintIR
from helao.core.models.hlostatus import HloStatus


# Dependencies:
# pip install pytest-mock
import pytest

"""
Code Analysis

Main functionalities:
The SprintIR class is responsible for controlling a CO2 sensor and acquiring CO2 measurements. It communicates with the sensor through a serial port and continuously polls for CO2 levels. It can perform both triggered and continuous measurements, and it stores the acquired data in a unified database. The class also handles the start and stop of measurements, as well as the management of active actions.

Methods:
- set_IO_signalq_nowait: sets the IO signal queue without waiting
- set_IO_signalq: sets the IO signal queue and waits if it is full
- IOloop: trigger-acquire-read loop that always runs
- send: sends a command to the sensor and returns the response
- read_stream: reads the streaming value from the sensor
- poll_sensor_loop: async polling task that continuously polls for CO2 levels
- continuous_record: async task that performs continuous CO2 measurements
- acquire_co2: async task that performs triggered CO2 measurements
- shutdown: cancels the polling and recording tasks and closes the serial port

Fields:
- base: instance of the Base class
- config_dict: dictionary containing configuration parameters
- unified_db: instance of the UnifiedSampleDataAPI class
- com: instance of the serial.Serial class for communication with the sensor
- action: instance of the Action class for the current action
- active: instance of the ActiveParams class for the current active parameters
- start_margin: number of seconds to extend the trigger acquisition window
- start_time: time when the measurement started
- last_rec_time: time when the last measurement was recorded
- IO_signalq: asyncio queue for IO signals
- IO_do_meas: signal flag for intent to start/stop measurement
- IO_measuring: status flag of measurement
- event_loop: instance of the asyncio event loop
- recording_duration: duration of the recording in seconds
- recording_rate: seconds per acquisition
- allow_no_sample: flag to allow measurements without a sample
- FIFO_epoch: epoch of the first measurement in the FIFO buffer
- FIFO_header: header of the measurement in the FIFO buffer
- FIFO_column_headings: column headings of the measurement in the FIFO buffer
- FIFO_name: name of the measurement in the FIFO buffer
- IO_continue: flag to continue IO loop
- IOloop_run: flag to run IO loop
- polling_task: instance of the asyncio Task class for the polling loop
- recording_task: instance of the asyncio Task class for the recording loop
"""

class TestSprintIR:

    @pytest.mark.asyncio
    # Tests that the sensor is properly initialized and in polling mode. 
    @pytest.mark.asyncio
    async def test_initialize_sensor(self, mocker):
        # Happy path test
        # Mock the serial communication object
        mock_serial = mocker.Mock()
        mock_serial.read_until.side_effect = [
            b"Z 123\r\n",
            b"scaling_factor 1000\r\n",
            b"init_co2_filtered 456\r\n",
        ]
        mocker.patch("sprint_ir.serial.Serial", return_value=mock_serial)

        # Create a mock action server
        mock_action_serv = mocker.Mock()
        mock_action_serv.server_cfg = {"params": {"port": "/dev/ttyUSB0"}}

        # Create a SprintIR object and check that the sensor is properly initialized
        sprint_ir = SprintIR(mock_action_serv)
        assert sprint_ir.fw == {"scaling_factor": 1000, "init_co2_filtered": 456}
        assert mock_serial.write.call_args_list == [
            mocker.call(b"K 2\r\n"),
            mocker.call(b"! 0\r\n"),
            mocker.call(b"Y\r\n"),
            mocker.call(b"! 0\r\n"),
            mocker.call(b"Y\r\n"),
            mocker.call(b"! 0\r\n"),
            mocker.call(b"Y\r\n"),
            mocker.call(b"Z\r\n"),
            mocker.call(b"Z\r\n"),
            mocker.call(b"scaling_factor\r\n"),
            mocker.call(b"init_co2_filtered\r\n"),
        ]

    # Tests that the CO2 level is successfully acquired and recorded for the set duration. 
    @pytest.mark.asyncio
    async def test_acquire_co2(self, mocker):
        # Happy path test
        # Mock the serial communication object and read_stream method
        mock_serial = mocker.Mock()
        mock_serial.read_until.side_effect = [
            b"Z 123\r\n",
            b"Z 234\r\n",
            b"",
            b"",
            b"",
        ]
        mocker.patch("sprint_ir.serial.Serial", return_value=mock_serial)
        mocker.patch("sprint_ir.SprintIR.read_stream", return_value="123")

        # Create a mock action and action server
        mock_action = mocker.Mock()
        mock_action.action_status = []
        mock_action.finish.return_value = None
        mock_action_serv = mocker.Mock()
        mock_action_serv.estop = False

        # Create a SprintIR object and acquire CO2 for 2 seconds
        sprint_ir = SprintIR(mock_action_serv)
        sprint_ir.recording_duration = 2
        active_dict = await sprint_ir.acquire_co2(mock_action)

        # Check that the active dict contains the expected data and that the action was properly finished
        assert active_dict == {"co2_ppm": 123000}
        assert mock_action.action_status == [HloStatus.finished]
        assert mock_action.finish.call_count == 1

    # Tests that the class handles the case where the sensor does not respond to commands. 
    @pytest.mark.asyncio
    async def test_sensor_not_responding(self, mocker):
        # Edge case test
        # Mock the serial communication object to not respond to commands
        mock_serial = mocker.Mock()
        mock_serial.read_until.return_value = b""
        mocker.patch("sprint_ir.serial.Serial", return_value=mock_serial)

        # Create a mock action and action server
        mock_action = mocker.Mock()
        mock_action.action_status = []
        mock_action_serv = mocker.Mock()
        mock_action_serv.estop = False

        # Create a SprintIR object and acquire CO2 for 2 seconds
        sprint_ir = SprintIR(mock_action_serv)
        sprint_ir.recording_duration = 2
        active_dict = await sprint_ir.acquire_co2(mock_action)

        # Check that the active dict is empty and that the action was properly finished with an error status
        assert active_dict == {}
        assert mock_action.action_status == [HloStatus.errored]
        assert mock_action.finish.call_count == 1

    # Tests that the class handles the case where the CO2 level is outside of the expected range. 
    @pytest.mark.asyncio
    async def test_co2_outside_range(self, mocker):
        # Edge case test
        # Mock the serial communication object to return an unreasonable CO2 level
        mock_serial = mocker.Mock()
        mock_serial.read_until.side_effect = [
            b"Z 0\r\n",
            b"Z 1000000\r\n",
        ]
        mocker.patch("sprint_ir.serial.Serial", return_value=mock_serial)

        # Create a mock action and action server
        mock_action = mocker.Mock()
        mock_action.action_status = []
        mock_action_serv = mocker.Mock()
        mock_action_serv.estop = False

        # Create a SprintIR object and acquire CO2 for 2 seconds
        sprint_ir = SprintIR(mock_action_serv)
        sprint_ir.recording_duration = 2
        active_dict = await sprint_ir.acquire_co2(mock_action)

        # Check that the active dict is empty and that the action was properly finished with an error status
        assert active_dict == {}
        assert mock_action.action_status == [HloStatus.errored]
        assert mock_action.finish.call_count == 1

    # Tests that the class handles the case where the recording duration is set to 0. 
    @pytest.mark.asyncio
    async def test_recording_duration_zero(self, mocker):
        # Edge case test
        # Create a mock action and action server
        mock_action = mocker.Mock()
        mock_action.action_status = []
        mock_action_serv = mocker.Mock()
        mock_action_serv.estop = False